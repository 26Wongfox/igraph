/* -*- mode: C -*-  */
/* 
   IGraph library.
   Copyright (C) 2003, 2004, 2005  Gabor Csardi <csardi@rmki.kfki.hu>
   MTA RMKI, Konkoly-Thege Miklos st. 29-33, Budapest 1121, Hungary
   
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 
   02110-1301 USA

*/

#include "memory.h"
#include "random.h"
#include "error.h"

#include <assert.h>
#include <string.h> 		/* memcpy & co. */
#include <stdlib.h>

/** 
 * \section about_igraph_matrix_t_objects About \type igraph_matrix_t objects
 * 
 * <para>This type is just an interface to \type igraph_vector_t.</para>
 *
 * <para>The \type igraph_matrix_t type usually stores n
 * elements in O(n) space, but not always, see the documentation of
 * the vector type.</para>
 */

/**
 * \section igraph_matrix_constructor_and_destructor Matrix constructors and
 * destructors
 */

/**
 * \ingroup matrix
 * \function igraph_matrix_init
 * \brief Initializes a matrix.
 * 
 * </para><para>
 * Every matrix needs to be initialized before using it, this is done
 * by calling this function. A matrix has to be destroyed if it is not
 * needed any more, see \ref igraph_matrix_destroy().
 * \param m Pointer to a not yet initialized matrix object to be
 *        initialized. 
 * \param nrow The number of rows in the matrix.
 * \param ncol The number of columns in the matrix.
 * \return Error code.
 *
 * Time complexity: usually O(n), 
 * n is the
 * number of elements in the matrix.
 */

int FUNCTION(igraph_matrix,init)(TYPE(igraph_matrix) *m, long int nrow, long int ncol) {
  int ret1;
  ret1=FUNCTION(igraph_vector,init)(&m->data, nrow*ncol);
  m->nrow=nrow;
  m->ncol=ncol;
  return ret1;
}

/** 
 * \ingroup matrix
 * \function igraph_matrix_destroy
 * \brief Destroys a matrix object.
 * 
 * </para><para>
 * This function frees all the memory allocated for a matrix
 * object. The destroyed object needs to be reinitialized before using
 * it again.
 * \param m The matrix to destroy.
 * 
 * Time complexity: operating system dependent.
 */ 

void FUNCTION(igraph_matrix,destroy)(TYPE(igraph_matrix) *m) {
  FUNCTION(igraph_vector,destroy)(&m->data);
}

/**
 * \section igraph_matrix_accessing_elements Accessing elements of a matrix
 */

/**
 * \ingroup matrix
 * \function igraph_matrix_resize
 * \brief Resizes a matrix.
 *
 * </para><para>
 * This function resizes a matrix by adding more elements to it.
 * The matrix contains arbitrary data after resizing it.
 * Ie. after calling this function you cannot expect that element
 * (i,j) in the matrix remains the
 * same as before.  
 * \param m Pointer to an already initialized matrix object.
 * \param nrow The number of rows in the resized matrix.
 * \param ncol The number of columns in the resized matrix.
 * \return Error code.
 * 
 * Time complexity: O(1) if the
 * matrix gets smaller, usually O(n)
 * if it gets larger, n is the 
 * number of elements in the resized matrix.
 */

int FUNCTION(igraph_matrix,resize)(TYPE(igraph_matrix) *m, long int nrow, long int ncol) {
  FUNCTION(igraph_vector,resize)(&m->data, nrow*ncol);
  m->nrow=nrow;
  m->ncol=ncol;
  return 0;
}

/**
 * \ingroup matrix
 * \function igraph_matrix_size
 * \brief The number of elements in a matrix.
 * 
 * \param m Pointer to an initialized matrix object.
 * \return The size of the matrix.
 *
 * Time complexity: O(1).
 */

long int FUNCTION(igraph_matrix,size)(const TYPE(igraph_matrix) *m) {
  return (m->nrow) * (m->ncol);
}

/**
 * \ingroup matrix
 * \function igraph_matrix_nrow
 * \brief The number of rows in a matrix.
 * 
 * \param m Pointer to an initialized matrix object.
 * \return The number of rows in the matrix.
 * 
 * Time complexity: O(1).
 */

long int FUNCTION(igraph_matrix,nrow)(const TYPE(igraph_matrix) *m) {
  return m->nrow;
}

/**
 * \ingroup matrix
 * \function igraph_matrix_ncol
 * \brief The number of columns in a matrix.
 * 
 * \param m Pointer to an initialized matrix object.
 * \return The number of columns in the matrix.
 * 
 * Time complexity: O(1).
 */

long int FUNCTION(igraph_matrix,ncol)(const TYPE(igraph_matrix) *m) {
  return m->ncol;
}

/** 
 * \ingroup matrix
 * \brief Copies a matrix to a regular C array.
 *
 * </para><para>
 * The matrix is copied columnwise, as this is the format most
 * programs and languages use.
 * The C array should be of sufficient size, there are (of course) not
 * range checks done.
 * \param m Pointer to an initialized matrix object.
 * \param to Pointer to a C array, the place to copy the data to.
 * \return Error code.
 *
 * Time complexity: O(n),
 * n is the number of 
 * elements in the matrix.
 */

int FUNCTION(igraph_matrix,copy_to)(const TYPE(igraph_matrix) *m, BASE *to) {
  FUNCTION(igraph_vector,copy_to)(&m->data, to);
  return 0;
}

/** 
 * \ingroup matrix
 * \brief Sets all element in a matrix to zero.
 * 
 * \param m Pointer to an initialized matrix object.
 * \return Error code, always returns with success.
 * 
 * Time complexity: O(n),
 * n is the number of  elements in
 * the matrix. 
 */

int FUNCTION(igraph_matrix,null)(TYPE(igraph_matrix) *m) {
  FUNCTION(igraph_vector,null)(&m->data);
  return 0;
}

/**
 * \ingroup matrix
 * \function igraph_matrix_add_cols
 * \brief Adds columns to a matrix.
 * \param m The matrix object.
 * \param n The number of columns to add.
 * \return Error code, \c IGRAPH_ENOMEM if there is
 *   not enough memory to perform the operation.
 *
 * Time complexity: linear with the number of elements of the new,
 * resized matrix.
 */

int FUNCTION(igraph_matrix,add_cols)(TYPE(igraph_matrix) *m, long int n) {
  FUNCTION(igraph_matrix,resize)(m, m->nrow, m->ncol+n);
  return 0;
}

/**
 * \ingroup matrix
 * \function igraph_matrix_add_rows
 * \brief Adds rows to a matrix.
 * \param m The matrix object.
 * \param n The number of rows to add.
 * \return Error code, \c IGRAPH_ENOMEM if there
 *   isn't enough memory for the operation.
 * 
 * Time complexity: linear with the number of elements of the new,
 * resized, matrix.
 */

int FUNCTION(igraph_matrix,add_rows)(TYPE(igraph_matrix) *m, long int n) {
  long int i;
  FUNCTION(igraph_vector,resize)(&m->data, (m->ncol)*(m->nrow+n));
  for (i=m->ncol-1; i>=0; i--) {
    FUNCTION(igraph_vector,move_interval)(&m->data, (m->nrow)*i, (m->nrow)*(i+1),
					  (m->nrow+n)*i);
  }
  m->nrow += n;
  return 0;
}

/**
 * \ingroup matrix
 * \function igraph_matrix_remove_col
 * \brief Removes a column from a matrix.
 * 
 * \param m The matrix object.
 * \param col The column to remove.
 * \return Error code, always returns with success. 
 * 
 * Time complexity: linear with the number of elements of the new,
 * resized matrix.
 */

int FUNCTION(igraph_matrix,remove_col)(TYPE(igraph_matrix) *m, long int col) {
  FUNCTION(igraph_vector,remove_section)(&m->data, (m->nrow)*col, (m->nrow)*(col+1));
  m->ncol--;
  return 0;
}

/**
 * \ingroup matrix
 * \function igraph_matrix_permdelete_rows
 * \brief Removes rows from a matrix (for internal use).
 * 
 * Time complexity: linear with the number of elements of the original
 * matrix. 
 */

int FUNCTION(igraph_matrix,permdelete_rows)(TYPE(igraph_matrix) *m, long int *index, long int nremove) {
  long int i, j;
  for (i=0; i<m->ncol; i++) {
    for (j=0; j<m->nrow; j++) {
      if (index[j] != 0) {
        MATRIX(*m, index[j]-1, i) = MATRIX(*m, j, i);
      }
    }
  }
  /* Remove unnecessary elements from the end of each column */
  for (i=0; i<m->ncol; i++)
    FUNCTION(igraph_vector,remove_section)(&m->data,
      (i+1)*(m->nrow-nremove), (i+1)*(m->nrow-nremove)+nremove);
  FUNCTION(igraph_matrix,resize)(m, m->nrow-nremove, m->ncol);

  return 0;
}

/**
 * \ingroup matrix
 * \function igraph_matrix_delete_rows_neg
 * \brief Removes columns from a matrix (for internal use).
 * 
 * Time complexity: linear with the number of elements of the original
 * matrix. 
 */

int FUNCTION(igraph_matrix,delete_rows_neg)(TYPE(igraph_matrix) *m, 
					    const igraph_vector_t *neg, long int nremove) {
  long int i, j, idx=0;
  for (i=0; i<m->ncol; i++) {
    for (j=0; j<m->nrow; j++) {
      if (VECTOR(*neg)[j] >= 0) {
	MATRIX(*m, idx++, i) = MATRIX(*m, j, i);
      } 
    }
    idx=0;
  }
  FUNCTION(igraph_matrix,resize)(m, m->nrow-nremove, m->ncol);

  return 0;
}

/**
 * \ingroup matrix
 * \function igraph_matrix_copy
 * \brief Copies a matrix.
 *
 * </para><para>
 * Creates a matrix object by copying another one.
 * \param to Pointer to an uninitialized matrix object.
 * \param from The initialized matrix object to copy.
 * \return Error code, \c IGRAPH_ENOMEM if there
 *   isn't enough memory to allocate the new matrix.
 * 
 * Time complexity: O(n), the number
 * of elements in the matrix.
 */

int FUNCTION(igraph_matrix,copy)(TYPE(igraph_matrix) *to, const TYPE(igraph_matrix) *from) {
  to->nrow = from->nrow;
  to->ncol = from->ncol;
  return FUNCTION(igraph_vector,copy)(&to->data, &from->data);
}

/**
 * \function igraph_matrix_max
 * 
 * Returns the maximal element of a matrix.
 * \param m The matrix object.
 * \return The maximum element. For empty matrix the returned value is
 * undefined. 
 * 
 * Added in version 0.2.</para><para>
 *
 * Time complexity: O(n), the number of elements in the matrix.
 */

igraph_real_t FUNCTION(igraph_matrix,max)(const TYPE(igraph_matrix) *m) {
  return FUNCTION(igraph_vector,max)(&m->data);
}

/**
 * \function igraph_matrix_multiply
 * 
 * Multiplies each element of the matrix by a constant.
 * \param m The matrix.
 * \param by The constant.
 *
 * Added in version 0.2.</para><para>
 * 
 * Time complexity: O(n), the number of elements in the matrix.
 */

void FUNCTION(igraph_matrix,multiply)(TYPE(igraph_matrix) *m, BASE by) {
  FUNCTION(igraph_vector,multiply)(&m->data, by);
}

int FUNCTION(igraph_matrix,select_rows)(const TYPE(igraph_matrix) *m, 
					TYPE(igraph_matrix) *res, 
					const igraph_vector_t *rows) {
  long int norows=igraph_vector_size(rows);
  long int i, j, ncols=FUNCTION(igraph_matrix,ncol)(m);
  
  IGRAPH_CHECK(FUNCTION(igraph_matrix,resize)(res, norows, ncols));
  for (i=0; i<norows; i++) {
    for (j=0; j<ncols; j++) {
      MATRIX(*res, i, j) = MATRIX(*m, (long int)VECTOR(*rows)[i], j);
    }
  }
  
  return 0;
}

int FUNCTION(igraph_matrix,get_col)(const TYPE(igraph_matrix) *m, 
				    TYPE(igraph_vector) *res,
				    long int index) {
  long int nrow=FUNCTION(igraph_matrix,nrow)(m);

  IGRAPH_CHECK(FUNCTION(igraph_vector,get_interval)(&m->data, res, 
						    nrow*index, nrow*(index+1)));
  return 0;
}

igraph_real_t FUNCTION(igraph_matrix,sum)(const TYPE(igraph_matrix) *m) {
  return FUNCTION(igraph_vector,sum)(&m->data);
}

igraph_bool_t FUNCTION(igraph_matrix,is_equal)(const TYPE(igraph_matrix) *m1, 
					      const TYPE(igraph_matrix) *m2) {
  return FUNCTION(igraph_vector,is_equal)(&m1->data, &m2->data);
}

BASE FUNCTION(igraph_matrix,maxdifference)(const TYPE(igraph_matrix) *m1,
					   const TYPE(igraph_matrix) *m2) {
  long int col1=FUNCTION(igraph_matrix,ncol)(m1);
  long int col2=FUNCTION(igraph_matrix,ncol)(m2);
  long int row1=FUNCTION(igraph_matrix,nrow)(m1);
  long int row2=FUNCTION(igraph_matrix,nrow)(m2);
  if (col1 != col2 || row1 != row2) {
    IGRAPH_WARNING("Comparing non-conformant matrices");
  }
  return FUNCTION(igraph_vector,maxdifference)(&m1->data, &m2->data);
}

int FUNCTION(igraph_matrix,transpose)(TYPE(igraph_matrix) *m) {
  long int nrow=m->nrow;
  long int ncol=m->ncol;
  if (nrow>1 && ncol>1) {
    TYPE(igraph_vector) newdata;
    long int i, size=nrow*ncol, mod=size-1;
    FUNCTION(igraph_vector,init)(&newdata, size);
    IGRAPH_FINALLY(FUNCTION(igraph_vector,destroy), &newdata);
    for (i=0; i<size; i++) {
      VECTOR(newdata)[i] = VECTOR(m->data)[ (i*nrow) % mod ];
    }
    VECTOR(newdata)[size-1]=VECTOR(m->data)[size-1];
    FUNCTION(igraph_vector,destroy)(&m->data);
    IGRAPH_FINALLY_CLEAN(1);
    m->data=newdata;
  }
  m->nrow=ncol;
  m->ncol=nrow;
  
  return 0;
}
