/* -*- mode: C -*-  */
/*
  Microscopic update rules for dealing with agent-level strategy revision.
  Copyright (C) 2011 Minh Van Nguyen <nguyenminh2@gmail.com>

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
  02110-1301 USA
*/

#include "igraph_interface.h"
#include "igraph_microscopic_update.h"
#include "igraph_nongraph.h"

/**
 * Internal use only.
 * A set of standard tests to be performed prior to strategy updates. The
 * tests contained in this function are common to many strategy revision
 * functions in this file. This function is meant to be invoked from within
 * a specific strategy update function in order to perform certain common
 * tests, including sanity checks and conditions under which no strategy
 * updates are necessary.
 *
 * \param graph The graph object representing the game network. This cannot
 *        be the empty or trivial graph, but must have at least two vertices
 *        and one edge. If \p graph has one vertex, then no strategy update
 *        would take place. Furthermore, if \p graph has at least two vertices
 *        but zero edges, then strategy update would also not take place.
 * \param vid The vertex whose strategy is to be updated. It is assumed that
 *        \p vid represents a vertex in \p graph. No checking is performed and
 *        it is your responsibility to ensure that \p vid is indeed a vertex
 *        of \p graph. If an isolated vertex is provided, i.e. the input
 *        vertex has degree 0, then no strategy update would take place and
 *        \p vid would retain its current strategy. Strategy update would also
 *        not take place if the local neighbourhood of \p vid are its
 *        in-neighbours (respectively out-neighbours), but \p vid has zero
 *        in-neighbours (respectively out-neighbours). Loops are ignored in
 *        computing the degree (in, out, all) of \p vid.
 * \param quantities A vector of quantities providing the quantity of each
 *        vertex in \p graph. Think of each entry of the vector as being
 *        generated by a function such as the fitness function for the game.
 *        So if the vector represents fitness quantities, then each vector
 *        entry is the fitness of some vertex. The length of this vector must
 *        be the same as the number of vertices in the vertex set of \p graph.
 * \param strategies A vector of the current strategies for the vertex
 *        population. Each strategy is identified with a nonnegative integer,
 *        whose interpretation depends on the payoff matrix of the game.
 *        Generally we use the strategy ID as a row or column index of the
 *        payoff matrix. The length of this vector must be the same as the
 *        number of vertices in the vertex set of \p graph.
 * \param mode Defines the sort of neighbourhood to consider for \p vid. If
 *        \p graph is undirected, then we use all the immediate neighbours of
 *        \p vid. Thus if you know that \p graph is undirected, then it is safe
 *        to pass the value \p IGRAPH_ALL here. Supported values are:
 *        \clist
 *        \cli IGRAPH_OUT
 *          Use the out-neighbours of \p vid. This option is only relevant
 *          when \p graph is a directed graph.
 *        \cli IGRAPH_IN
 *          Use the in-neighbours of \p vid. Again this option is only relevant
 *          when \p graph is a directed graph.
 *        \cli IGRAPH_ALL
 *          Use both the in- and out-neighbours of \p vid. This option is only
 *          relevant if \p graph is a digraph. Also use this value if
 *          \p graph is undirected.
 *        \endclist
 * \return Codes:
 *         \clist
 *         \cli IGRAPH_EINVAL
 *           This error code is returned in each of the following cases:
 *           (1) Any of the parameters \p graph, \p quantities, or
 *           \p strategies is a null pointer. (2) The vector \p quantities
 *           or \p strategies has a length different from the number of
 *           vertices in \p graph. (3) The parameter \p graph is the empty
 *           or null graph, i.e. the graph with zero vertices and edges.
 *         \cli IGRAPH_SUCCESS
 *           This signal is returned if we should proceed with strategy update.
 *           Otherwise no strategy revision is necessary.
 *         \endclist
 */

int igraph_microscopic_standard_tests(const igraph_t *graph,
                                      igraph_integer_t vid,
                                      const igraph_vector_t *quantities,
                                      const igraph_vector_t *strategies,
                                      igraph_neimode_t mode) {
  /* sanity checks */
  if (graph == NULL) {
    IGRAPH_ERROR("Graph is a null pointer", IGRAPH_EINVAL);
  }
  if (quantities == NULL) {
    IGRAPH_ERROR("Quantities vector is a null pointer", IGRAPH_EINVAL);
  }
  if (strategies == NULL) {
    IGRAPH_ERROR("Strategies vector is a null pointer", IGRAPH_EINVAL);
  }

  igraph_integer_t nvert = igraph_vcount(graph);
  /* the empty graph */
  if (nvert < 1) {
    IGRAPH_ERROR("Graph cannot be the empty graph", IGRAPH_EINVAL);
  }
  /* invalid vector length */
  if (nvert != (igraph_integer_t)igraph_vector_size(quantities)) {
    IGRAPH_ERROR("Size of quantities vector different from number of vertices",
                 IGRAPH_EINVAL);
  }
  if (nvert != (igraph_integer_t)igraph_vector_size(strategies)) {
    IGRAPH_ERROR("Size of strategies vector different from number of vertices",
                 IGRAPH_EINVAL);
  }

  /* Various conditions under which no strategy updates will take place. That
   * is, the vertex retains its current strategy.
   */
  /* given graph has < 2 vertices */
  if (nvert < 2) {
    return IGRAPH_FAILURE;
  }
  /* graph has >= 2 vertices, but no edges */
  if (igraph_ecount(graph) < 1) {
    return IGRAPH_FAILURE;
  }
  /* Given vertex is isolated (undirected graph), has zero out-degree (for */
  /* out-neighbours), or has zero in-degree (for in-neighbours). */
  igraph_vector_t degv;
  IGRAPH_VECTOR_INIT_FINALLY(&degv, 1);
  IGRAPH_CHECK(igraph_degree(graph, &degv, igraph_vss_1(vid),
			     mode, IGRAPH_NO_LOOPS));
  if (VECTOR(degv)[0] < 1) {
    igraph_vector_destroy(&degv);
    IGRAPH_FINALLY_CLEAN(1);
    return IGRAPH_FAILURE;
  }
  igraph_vector_destroy(&degv);
  IGRAPH_FINALLY_CLEAN(1);

  return IGRAPH_SUCCESS;
}

/**
 * \ingroup spatialgames
 * \function igraph_deterministic_optimal_imitation
 * \brief Adopt a strategy via deterministic optimal imitation.
 *
 * A simple deterministic imitation strategy where a vertex revises its
 * strategy to that which yields a local optimal. Here "local" is with
 * respect to the immediate neighbours of the vertex. The vertex retains its
 * current strategy where this strategy yields a locally optimal quantity.
 * The quantity in this case could be a measure such as fitness.
 *
 * \param graph The graph object representing the game network. This cannot
 *        be the empty or trivial graph, but must have at least two vertices
 *        and one edge. If \p graph has one vertex, then no strategy update
 *        would take place. Furthermore, if \p graph has at least two vertices
 *        but zero edges, then strategy update would also not take place.
 * \param vid The vertex whose strategy is to be updated. It is assumed that
 *        \p vid represents a vertex in \p graph. No checking is performed and
 *        it is your responsibility to ensure that \p vid is indeed a vertex
 *        of \p graph. If an isolated vertex is provided, i.e. the input
 *        vertex has degree 0, then no strategy update would take place and
 *        \p vid would retain its current strategy. Strategy update would also
 *        not take place if the local neighbourhood of \p vid are its
 *        in-neighbours (respectively out-neighbours), but \p vid has zero
 *        in-neighbours (respectively out-neighbours). Loops are ignored in
 *        computing the degree (in, out, all) of \p vid.
 * \param optimality Logical; controls the type of optimality to be used.
 *        Supported values are:
 *        \clist
 *        \cli IGRAPH_MAXIMUM
 *          Use maximum deterministic imitation, where the strategy of the
 *          vertex with maximum quantity (e.g. fitness) would be adopted. We
 *          update the strategy of \p vid to that which yields a local
 *          maximum.
 *        \cli IGRAPH_MINIMUM
 *          Use minimum deterministic imitation. That is, the strategy of the
 *          vertex with minimum quantity would be imitated. In other words,
 *          update to the strategy that yields a local minimum.
 *        \endclist
 * \param quantities A vector of quantities providing the quantity of each
 *        vertex in \p graph. Think of each entry of the vector as being
 *        generated by a function such as the fitness function for the game.
 *        So if the vector represents fitness quantities, then each vector
 *        entry is the fitness of some vertex. The length of this vector must
 *        be the same as the number of vertices in the vertex set of \p graph.
 * \param strategies A vector of the current strategies for the vertex
 *        population. The updated strategy for \p vid would be stored here.
 *        Each strategy is identified with a nonnegative integer, whose
 *        interpretation depends on the payoff matrix of the game. Generally
 *        we use the strategy ID as a row or column index of the payoff
 *        matrix. The length of this vector must be the same as the number of
 *        vertices in the vertex set of \p graph.
 * \param mode Defines the sort of neighbourhood to consider for \p vid. If
 *        \p graph is undirected, then we use all the immediate neighbours of
 *        \p vid. Thus if you know that \p graph is undirected, then it is safe
 *        to pass the value \p IGRAPH_ALL here. Supported values are:
 *        \clist
 *        \cli IGRAPH_OUT
 *          Use the out-neighbours of \p vid. This option is only relevant
 *          when \p graph is a directed graph.
 *        \cli IGRAPH_IN
 *          Use the in-neighbours of \p vid. Again this option is only relevant
 *          when \p graph is a directed graph.
 *        \cli IGRAPH_ALL
 *          Use both the in- and out-neighbours of \p vid. This option is only
 *          relevant if \p graph is a digraph. Also use this value if
 *          \p graph is undirected.
 *        \endclist
 * \return The error code \p IGRAPH_EINVAL is returned in each of the
 *         following cases: (1) Any of the parameters \p graph, \p quantities,
 *         or \p strategies is a null pointer. (2) The vector \p quantities
 *         or \p strategies has a length different from the number of vertices
 *         in \p graph. (3) The parameter \p graph is the empty or null graph,
 *         i.e. the graph with zero vertices and edges.
 *
 * Time complexity: O(2d), where d is the degree of the vertex \p vid.
 *
 * \example examples/simple/igraph_deterministic_optimal_imitation.c
 */

int igraph_deterministic_optimal_imitation(const igraph_t *graph,
                                           igraph_integer_t vid,
                                           igraph_optimal_t optimality,
                                           const igraph_vector_t *quantities,
                                           igraph_vector_t *strategies,
                                           igraph_neimode_t mode) {
  igraph_integer_t i, k, v;
  igraph_real_t q;
  igraph_vector_t adj;
  int ret;

  ret = igraph_microscopic_standard_tests(graph, vid, quantities,
					  strategies, mode);
  if (ret != IGRAPH_SUCCESS) {
    /* no strategy update should take place, so successful exit */
    return IGRAPH_SUCCESS;
  }

  /* Choose a locally optimal strategy to imitate. This can be either maximum
   * or minimum deterministic imitation. By now we know that the given vertex v
   * has degree >= 1 and at least 1 edge. Then within its immediate
   * neighbourhood adj(v) and including v itself, there exists a vertex whose
   * strategy yields a local optimal quantity.
   */
  /* Random permutation of adj(v). This ensures that if there are multiple */
  /* candidates with an optimal strategy, then we choose one such candidate */
  /* at random. */
  IGRAPH_VECTOR_INIT_FINALLY(&adj, 0);
  IGRAPH_CHECK(igraph_neighbors(graph, &adj, vid, mode));
  IGRAPH_CHECK(igraph_fisher_yates_shuffle(&adj));
  /* maximum deterministic imitation */
  i = vid;
  q = (igraph_real_t)VECTOR(*quantities)[vid];
  if (optimality == IGRAPH_MAXIMUM) {
    for (k = 0; k < igraph_vector_size(&adj); k++) {
      v = VECTOR(adj)[k];
      if ((igraph_real_t)VECTOR(*quantities)[v] > q) {
	i = v;
	q = (igraph_real_t)VECTOR(*quantities)[v];
      }
    }
  } else { /* minimum deterministic imitation */
    for (k = 0; k < igraph_vector_size(&adj); k++) {
      v = VECTOR(adj)[k];
      if ((igraph_real_t)VECTOR(*quantities)[v] < q) {
	i = v;
	q = (igraph_real_t)VECTOR(*quantities)[v];
      }
    }
  }
  /* Now i is a vertex with a locally optimal quantity, the value of which */
  /* is q. Update the strategy of vid to that of i. */
  VECTOR(*strategies)[vid] = VECTOR(*strategies)[i];
  igraph_vector_destroy(&adj);
  IGRAPH_FINALLY_CLEAN(1);

  return IGRAPH_SUCCESS;
}
